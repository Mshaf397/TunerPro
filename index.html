<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Microtonal Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    input, select, button, textarea {
      font-size: 1rem;
      margin: 5px 0;
      padding: 10px;
      width: 100%;
      max-width: 500px;
      background: #222;
      color: #eee;
      border: 1px solid #444;
    }
    canvas {
      width: 100%;
      height: 150px;
      background: #222;
      border: 1px solid #444;
      margin-top: 10px;
    }
    #pitchInfo {
      margin: 10px;
      font-size: 1.1em;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Microtonal Pitch Trainer</h1>

  <textarea id="sclEditor" rows="3">0,100,200,300,400,500,600,700,800,900,1000,1100</textarea>
  <button onclick="loadScale()">Load Scale</button>

  <select id="noteSelector"></select>
  <button onclick="toggleTone()">Toggle Tone</button>
  <button onclick="startMic()">Start Mic</button>

  <canvas id="needle"></canvas>
  <div id="pitchInfo">Pitch: – Hz | Cents Off: –</div>

  <script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let osc = null;
    let micActive = false;
    let selectedFreq = 440;
    let scl = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100];
    const canvas = document.getElementById("needle");
    const ctx = canvas.getContext("2d");

    function loadScale() {
      const text = document.getElementById("sclEditor").value;
      scl = text.split(",").map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
      populateNoteSelector();
    }

    function populateNoteSelector() {
      const sel = document.getElementById("noteSelector");
      sel.innerHTML = "";
      scl.forEach((cents, i) => {
        const freq = 440 * Math.pow(2, cents / 1200);
        const option = document.createElement("option");
        option.value = freq;
        option.text = `${i}: ${freq.toFixed(2)} Hz (${cents}¢)`;
        sel.appendChild(option);
      });
    }

    document.getElementById("noteSelector").addEventListener("change", e => {
      selectedFreq = parseFloat(e.target.value);
      if (osc) osc.frequency.setValueAtTime(selectedFreq, audioCtx.currentTime);
    });

    function toggleTone() {
      if (osc) {
        osc.stop();
        osc = null;
      } else {
        osc = audioCtx.createOscillator();
        osc.type = "sine";
        osc.frequency.value = parseFloat(document.getElementById("noteSelector").value);
        osc.connect(audioCtx.destination);
        osc.start();
      }
    }

    async function startMic() {
      if (micActive) return;
      micActive = true;
      await audioCtx.resume();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const source = audioCtx.createMediaStreamSource(stream);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const buffer = new Float32Array(analyser.fftSize);
      source.connect(analyser);

      function detect() {
        analyser.getFloatTimeDomainData(buffer);
        const pitch = autoCorrelate(buffer, audioCtx.sampleRate);
        if (pitch) {
          const centsOff = 1200 * Math.log2(pitch / selectedFreq);
          drawNeedle(centsOff);
          document.getElementById("pitchInfo").innerText =
            `Pitch: ${pitch.toFixed(2)} Hz | Cents Off: ${centsOff.toFixed(1)}`;
        } else {
          drawNeedle(null);
          document.getElementById("pitchInfo").innerText =
            `Pitch: – Hz | Cents Off: –`;
        }
        requestAnimationFrame(detect);
      }
      detect();
    }

    function drawNeedle(cents) {
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      const mid = w / 2;
      const range = 50;
      ctx.strokeStyle = "#888";
      ctx.beginPath();
      ctx.moveTo(mid, 0);
      ctx.lineTo(mid, h);
      ctx.stroke();

      if (cents === null) return;

      const pos = mid + (cents / range) * (w / 2);
      ctx.strokeStyle = Math.abs(cents) < 5 ? "#0f0" : "#f00";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(pos, 0);
      ctx.lineTo(pos, h);
      ctx.stroke();
    }

    function autoCorrelate(buf, sampleRate) {
      let SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return null;

      let bestOffset = -1, bestCorr = 0;
      for (let offset = 20; offset < 1000; offset++) {
        let corr = 0;
        for (let i = 0; i < SIZE - offset; i++) {
          corr += buf[i] * buf[i + offset];
        }
        corr /= (SIZE - offset);
        if (corr > bestCorr) {
          bestCorr = corr;
          bestOffset = offset;
        }
      }

      return bestCorr > 0.9 ? sampleRate / bestOffset : null;
    }

    loadScale();
  </script>
</body>
</html>